# 認証ガードとユーザー取得フローまとめ

サーバー側・クライアント側それぞれで認証情報を扱う仕組みが充実しており、どれをいつ使えば良いのか迷いやすいため、主要コンポーネントと利用シナリオを整理しました。新メンバーが「どこで何を呼べば安全にユーザー情報を扱えるのか」を素早く把握できることが目的です。

---

## 1. 認証レイヤーの全体像

```
ブラウザ → proxy.ts（redirectProxy）
        → App Router layout/page（authGuard）
            → ドメインサービス（requireCurrentUser）
                → userService（DB）
```

- **proxy 層 (`src/proxies/redirect.ts`)**: ルーティングより前に動作し、`redirect.config.ts` のルールを使って即時リダイレクトやトースト通知を行う。ここで `resolveSessionUser()` を使い Cookie の JWT を判定します。
- **レイアウト層 (`authGuard`)**: `(protected)` 配下などページグループごとに利用。`allowRoles` / `allowStatuses` / `redirectTo` でアクセス可否を制御し、失敗時は `redirect()` を実行。
- **ページ層 (`requireCurrentUser`)**: 実際にユーザー情報を読み込んで描画する前に呼び出し、セッションに他人の ID が入っていないか・DB にレコードが残っているかを最終確認します。

この 3 層が連携することで「URL レベルの規則」→「SSR レイアウトでの権限ガード」→「DB レコード取得」というフェイルセーフを構築しています。

---

## 2. サーバー側で使う主要 API

| 役割 | ファイル | 使いどころ |
| --- | --- | --- |
| ルールベースの先制リダイレクト | `src/proxies/redirect.ts` | `redirect.config.ts` に従って `/login` へ飛ばす、ゲスト専用ページから認証済みユーザーを追い出す等。
| ルート単位の認可 | `src/features/auth/services/server/authorization.ts` (`authGuard`) | `layout.tsx` や `page.tsx` 冒頭でリダイレクトを伴うガードを行いたいとき。
| セッションユーザーに紐づく DB レコード取得 | `src/features/user/services/server/requireCurrentUser.ts` | マイページなど「自分自身の詳細情報が存在する前提」のページ。`behavior` オプションで `notFound`/`redirect`/`null` を切替可能。

### 2.1 `authGuard` の例

```tsx
// src/app/(user)/(protected)/layout.tsx
await authGuard({ allowRoles: ["admin", "user"], redirectTo: "/login" });
```

### 2.2 `requireCurrentUser` の例

```tsx
import { requireCurrentUser } from "@/features/user/services/server/requireCurrentUser";

export default async function UserProfileEditPage() {
  const user = await requireCurrentUser();
  return <UserProfileEdit user={user} />;
}

// 取得に失敗したらログインへ戻したい場合
await requireCurrentUser({ behavior: "redirect", redirectTo: "/login" });
```

`requireCurrentUser` は `cache()` でリクエスト内の結果を共有するため、同じページ内で複数回呼び出しても DB アクセスは 1 度で済みます。プロフィール更新 API のように同一リクエスト中で値を更新するケースは通常存在しないため、この挙動で問題ありません。

---

## 3. クライアント側での認証情報共有

1. **`AuthSessionProvider`** (`src/app/layout.tsx`) が SSR 時に Cookie を検証し、初期 `SessionUser` を決定。
2. **`AuthSessionClientProvider`** が `useState` でユーザー情報を保持し、`refreshSession()` を提供。
3. **`useAuthSession()`** (`src/features/auth/hooks/useAuthSession.ts`) で Context を参照し、`user` / `isAuthenticated` / `refreshSession` を取得。

クライアントコンポーネントで「ログイン済みか」「ユーザー名は？」といった情報が必要な場合は、そのまま `useAuthSession()` を呼べば props リレー無しで共通の状態を扱えます。`refreshSession()` を呼ぶと `/api/auth/session` で JWT を再検証し、結果によって `user` が更新されます。

---

## 4. API とセッション更新の流れ

| 層 | 実装 | 主な責務 |
| --- | --- | --- |
| `app/api/auth/session` | `route.ts` | Cookie 取得 → `verifyUserToken` → `SessionUser` 返却＆トークン延命。失敗時は 401 で Cookie を消去。 |
| クライアントサービス | `src/features/auth/services/client/session.ts` (`fetchSession`) | axios で `/api/auth/session` を叩き、`normalizeHttpError` で例外を整理。 |
| Hooks/Context | `AuthSessionClientProvider` / `useAuthSession` | `refreshSession()` で `fetchSession` を呼び、結果を Context に反映。 |

ログアウト処理も同様で、`/api/auth/logout` → `services/client/logout.ts` → `useLogout` の順で役割が分かれています。UI は Hook か Context だけを知っていればよく、HTTP や Cookie 操作の詳細を覚える必要はありません。

---

## 5. よくあるパターンとベストプラクティス

- **レイアウトで `authGuard`、ページで `requireCurrentUser`** を呼ぶのが基本形。レイアウトで許可ロール／ステータスを決め、ページではユーザー存在チェックに集中します。
- **複数コンポーネントでユーザー情報が必要ならリレーする**: `requireCurrentUser` の返り値をヘッダーやフッターへ props で渡すか、レイアウト側で呼び出して `children` へ供給します（`cache` が効くため多少重複しても致命的ではない）。
- **クライアント UI は `useAuthSession` 落ち着け**: 「ログインボタンを隠す」「ユーザー名を表示する」などの用途では Context だけを参照し、サーバー用 API を直接触らない。サインアウト後やセッション延命後は `refreshSession()` の結果がそのまま UI に反映されます。
- **ルーティングレベルのリダイレクトが必要な場合は `redirect.config.ts`** を編集し、middleware 相当の `redirectProxy` で処理する。ページ内の条件分岐でリダイレクトを書くよりも統一感を保てます。

---

## 6. 参考リンク

- `docs/how-to/implementation/ユーザーのセッション管理やロールやステータスによるルート制限の方法.md`
- `docs/concepts/ユーザーセッションの管理方針と実装.md`
- `src/features/auth/services/server/authorization.ts`
- `src/features/user/services/server/requireCurrentUser.ts`
- `src/proxies/redirect.ts`

困ったときは上記ファイルを順に追い、どのレイヤーで何を判定しているのか確認してください。
