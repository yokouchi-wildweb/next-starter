# 汎用コンポーネントで構築するフォーム実装ガイド

このドキュメントでは、既存ドメインで採用しているフォーム実装の共通パターンを整理し、`components/Form` 以下の汎用コンポーネントを使って最小構成でフォームを構築する手順をまとめます。

## 前提知識

- フォームの状態管理は [`react-hook-form`](https://react-hook-form.com/) を利用します。
- Shadcn UI の `Form` コンポーネントをラップしたヘルパーを使用し、コンテキストを提供します。
- 入力フィールドは `FormFieldItem` と各種入力コンポーネント（`TextInput`、`SelectInput` など）を組み合わせて構築します。

## 基本構成のおさらい

実際のドメイン実装では次の 3 要素を組み合わせています。

1. **フォームコンテナ** – `useForm` で生成したインスタンスを `<Form {...form}>` で包む。
2. **`FormFieldItem`** – ラベル・入力本体・バリデーションメッセージをまとめる薄いラッパー。
3. **入力コンポーネント** – `TextInput`、`SelectInput`、`FileUrlInput` など、`field` を渡すだけで使えるパーツ群。

`src/components/Form` ディレクトリにはこれらの入力コンポーネントが網羅されているため、フォームを実装するときはまず既存のフィールド要素を優先的に利用し、足りない場合にのみ新規作成を検討します。

たとえばメールプレ登録フォームでは、`useForm` で値を管理しつつ `FormFieldItem` と `TextInput` を組み合わせて 1 フィールドを実装しています。

`FormFieldItem` の役割は、`react-hook-form` の `Controller` を内包し、子コンポーネントに `field` を渡すことだけです。これにより、各ドメインでのフォーム構築時に同じレイアウトとバリデーションエラー表示を得られます。

## 共通フィールドコンポーネントを作る

複数の画面で再利用したいフィールド群は、`<FormFieldItem>` を列挙したコンポーネントとして切り出します。サンプルドメインでは、カテゴリーや画像などのフィールドを 1 つの `SampleFields` にまとめており、フォーム本体では `<SampleFields control={form.control} ... />` として読み込むだけで済みます。

共通フィールドを切り出すときのポイントは以下のとおりです。

- `props` に `control` を受け取り、必要なオプションやアップロードハンドラを追加する。
- `FormFieldItem` の `name` は `FieldPath<TFieldValues>` で型付けし、`as FieldPath<TFieldValues>` のキャストで柔軟に対応する。
- `renderInput` に渡す関数で汎用入力コンポーネントへ `field` を渡し、必要な追加 props（`options`、`placeholder`、`onUpload` など）を付与する。

## 最小構成でフォームを作成する手順

1. **フォーム値の型を定義する**
   ```ts
   type FormValues = { email: string };
   ```
2. **`useForm` で初期化する**
   ```ts
   const form = useForm<FormValues>({
     resolver: zodResolver(SampleCreateSchema) as Resolver<FormValues>,
     mode: "onSubmit",
     shouldUnregister: false,
     defaultValues: { email: "" },
   });
   ```
   - `resolver`: Zod スキーマをバリデーションに利用します。`SampleCreateSchema` のようにドメイン固有のスキーマを渡し、`Resolver<FormValues>` にキャストすることで型整合性を保ちます。
   - `mode`: `"onSubmit"` を指定して、送信時にのみエラーチェックが走るようにしています。途中入力での細かいバリデーションが不要な画面ではこの設定がもっともシンプルです。
   - `shouldUnregister`: `false` とすることで、非表示になったフィールドでも値を保持し続けます。フォームの分岐が多いケースでも再入力を避けられます。
   - `defaultValues`: 初期値を明示的に定義し、`FormFieldItem` 側で `undefined` や `null` が予期しない挙動を起こさないようにします。ドメインごとに必要な項目をここで網羅します。
   > ※ `SampleCreateSchema` や `SampleCreateFields` はサンプル作成フォームの例です。各ドメインでは対応する Zod スキーマとフィールド型に置き換えてください。
3. **`Form` でラップした `<form>` を用意する**
   ```tsx
   <Form {...form}>
     <form onSubmit={form.handleSubmit(onSubmit)} noValidate>
       {/* フィールドをここに並べる */}
     </form>
   </Form>
   ```
4. **`FormFieldItem` + 入力コンポーネントでフィールドを配置する**
   ```tsx
   <FormFieldItem
     control={form.control}
     name="email"
     label={<span className="text-sm font-medium">メールアドレス</span>}
     renderInput={(field) => (
       <TextInput field={field} type="email" required placeholder="example@example.com" />
     )}
   />
   ```
5. **送信ボタンやルートエラー表示を追加する**（必要に応じて `Para` などのテキストコンポーネントを利用）。

以上のステップで、既存ドメインと同じ構造・見た目を持つ最小のフォームを構築できます。

### `useForm` の返り値（`UseFormReturn`）の活用ポイント

`useForm` の返り値である `form`（または `methods`）は `UseFormReturn<T>` 型で、次のようなプロパティを通してフォーム実装全体を支えています。

- `handleSubmit`: `<form onSubmit={handleSubmit(onSubmit)}>` のように利用し、バリデーションと送信処理をまとめてハンドリングします。
- `control`: `FormFieldItem` やその配下の入力コンポーネントに渡して、`react-hook-form` の状態管理と接続します。
- `formState`: `isSubmitting` などの状態値を持ち、送信中のボタン制御やローディング表示に利用します。
- `getValues` / `setValue`: ファイルアップロードの後処理など、UI の外から値を取得・更新したい場合に呼び出します。

これらのメソッドをコンポーネントに適切に配布することで、フォーム全体の状態管理を `UseFormReturn` オブジェクト 1 つに集約できます。

## 応用ヒント

- ファイルアップロードが必要な場合は `FileUrlInput` や `ImageUploaderField` を利用し、アップロード用のコールバックを props から受け取れるようにします。
- 数値や日付などの入力は、専用の `NumberInput` や `DateInput` を `renderInput` で呼び出すとバリデーションや UI を揃えられます。
- フィールドの並び順やレイアウトは `<FormFieldItem>` の順番で決まるため、必要な箇所だけを再利用することもできます。

## まとめ

- `FormFieldItem` はフォーム構築の共通レイアウト兼 `Controller` として機能します。
- 入力コンポーネントは `field` を受け取るシンプルな API を提供しているため、`renderInput` からそのまま渡すだけで利用できます。
- ドメイン固有のフォームでも、上記の最小ステップを踏めば迅速かつ統一された UI/UX を実現できます。
