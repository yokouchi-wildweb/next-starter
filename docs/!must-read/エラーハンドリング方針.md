# エラーハンドリング方針

本ドキュメントは「[アプリ構築における構成層](アプリ構築における構成層.md)」の分離方針に沿って、サーバー・クライアントを横断したエラー処理の標準ルールをまとめたものです。UI で都度複雑な分岐を記述せずに済むよう、責務を各層へ明確に割り振り、`HttpError` を介した一貫した例外フローを採用します。

## 1. 各層の責務

| 層 | 主な責務 | エラーの扱い |
| --- | --- | --- |
| **サーバードメインサービス** | ドメインロジックの実行 | ビジネスルール違反などユーザーへ伝えるべき事象では `DomainError` を throw し、`status` と分かりやすい `message` を設定する。想定外の例外はそのまま上位へ伝播させる。 |
| **API ルート** | HTTP レスポンスへの変換 | `DomainError` を JSON `{ message, status }` へ正規化し、それ以外の `Error` も `message` を含む JSON として返す。ログ出力や監視はこの層で行う。 |
| **クライアントサービス (axios ラッパー)** | HTTP 通信とレスポンス整形 | axios の例外を必ず `normalizeHttpError` で `HttpError` へ統一し、意味のあるフォールバックメッセージを付与して throw する。生の例外を上位へ渡さない。 |
| **CRUD/SWR フック** | データ取得・更新の React フック | `useSWR` / `useSWRMutation` のエラー型は `HttpError` 前提。サービスが返す `HttpError` をそのまま扱い、追加の正規化は行わない。HTTP 通信を介さずに例外が発生するケース（外部 SDK、ブラウザ標準 API、手動バリデーションなど）では `createHttpError` で `HttpError` を生成し、必要に応じて元の例外を `cause` に入れてから throw する。 |
| **UI コンポーネント** | 表示とユーザー操作の処理 | `err(error, fallback)` でユーザー向け文言を決定し、トーストやフォームエラーへ渡す。HTTP の詳細判定は行わない。 |

## 2. 共通エラー型 `HttpError`

`src/lib/errors/httpError.ts` に `HttpError` クラスとユーティリティを定義しています。

- `normalizeHttpError(error, fallbackMessage?)`
  - axios 由来のエラーを判定し、レスポンスボディの `message` があれば優先的に採用します。
  - `status`, `message`, `responseData`, `cause` を保持した `HttpError` を返します。
- `resolveErrorMessage(error, fallbackMessage)`
  - 任意の `unknown` から安全に表示用メッセージを得るためのラッパーです。内部で `normalizeHttpError` を利用します。
- `err(error, fallbackMessage)`
  - `resolveErrorMessage` の短縮エイリアス。UI ではこちらを優先的に利用します。
- `createHttpError(params)`
  - フックなどクライアント層で新たに例外を生成したい場合に利用します。`message` をはじめ、必要に応じて `status`, `responseData`, `cause` を指定できます。
  - 例として、ブラウザの標準 API を呼び出した結果が失敗した、外部 SDK が例外を投げた、ローカルバリデーションで想定外の状態になったといった HTTP 通信外のエラーを UI へ伝える際に利用します。
- `isHttpError(error)`
  - 型ガードとして利用できます。基本的には `normalizeHttpError` と `resolveErrorMessage` が代わりに担うため直接使う場面は限定的です。

## 3. クライアントサービス実装のルール

- クライアントサービスでは axios を必ず利用し（fetch は使用しない）、`try/catch` を設けて `normalizeHttpError` を通した上で再 throw してください。
- 通信エラー以外（設定値不足やクライアントサイドの前処理など）であっても、生の例外をそのまま投げず `normalizeHttpError` などを通じて必ず `HttpError` として返却します。
- フォールバックメッセージは「ユーザーが次に取れる行動を想像できる文言」にします（例: "ファイルのアップロードに失敗しました"）。
- アプリ全体に影響するロギングやアラートは `setApiErrorHandler((error) => { ... })` へ登録します。受け取る `HttpError` には `status` や `responseData` が含まれます。
- CRUD のイベントフック `registerCrudEventHandler` にも `HttpError` が流れるため、UI 層以外での集約処理（計測やリトライ指示など）に活用できます。

## 4. React フックと UI の利用方法

- `useDomain*` / `use*Domain` フックはすべて `HttpError` を返すよう型定義されています。`mutation.error` や `error` を受け取ったら、UI では `err` を呼び出すだけで安全に文言を決められます。
- トースト・ダイアログ・フォームエラーなど UI 側でのハンドリングは以下のワンパターンで記述できます。

  ```tsx
  try {
    await trigger(data);
    showToast("登録しました", "success");
  } catch (error) {
    showToast(err(error, "登録に失敗しました"), "error");
  }
  ```

- 追加でローカル状態を更新したい場合も、`HttpError` の `status` や `responseData` を確認すれば条件分岐が容易です（例: `error.status === 409` で重複メッセージを表示）。

## 5. クライアントでの HTTP クライアント選択

- クライアント環境では axios を標準とし、fetch の利用は禁止します。例外を `normalizeHttpError` に通した `HttpError` として throw することで、フック・UI の扱いを統一します。
- サーバー環境では Next.js 公式の最適化と親和性が高い `fetch` を利用しても構いません。サーバーサービスからクライアントへエラーを伝播させる場合は JSON で `message` を返し、クライアントサービス側で `HttpError` へ変換してください。

## 6. サーバー実装時の注意

- サーバーサービス層では、ユーザーへ伝えるべきエラーに対して `DomainError` を積極的に利用し、`message` を日本語で整備します。
- Next.js の API ルートでは、`DomainError` を検知して適切なステータス・メッセージを JSON で返す実装を徹底します。その他のエラーは 500 系として処理しつつ、メッセージはログのみで管理するなどポリシーを定めてください。
- これらの約束により、クライアント側は `HttpError` の `message` をそのままユーザーへ提示でき、文言の重複管理が不要になります。

## 7. 新規機能追加時のチェックリスト

1. サービス層で `DomainError` を適切に投げているか確認する。
2. API ルートで `DomainError` とその他のエラーを JSON レスポンスへ正規化しているか確認する。
3. クライアントサービスで `normalizeHttpError` を経由しているか確認する。
4. フックおよび UI コンポーネントで `err` を使用し、フォールバック文言を定義しているか確認する。
5. 必要に応じて `setApiErrorHandler` へロギング・監視処理を登録する。

以上のルールに従うことで、ドメイン横断で一貫したユーザー体験と保守性の高いエラーハンドリングを実現できます。
