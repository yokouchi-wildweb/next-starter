# DB種別の違いによる機能の差異

本ドキュメントでは、汎用 CRUD サービスの `search` メソッドを中心に、Neon（PostgreSQL/Drizzle）版と Firestore 版で利用できる機能やクエリ性能の差異を整理します。両実装は共通の `SearchParams` 型を引数に取りますが、バックエンドごとのサポート状況や実行方式が異なるため、呼び出し時の期待値を明確にしておく必要があります。

## 1. 機能対応状況サマリ

| 機能 | Neon (Drizzle) | Firestore |
| --- | --- | --- |
| ページング (`page`/`limit`) | SQL の `LIMIT` / `OFFSET` を直接利用。 | `page * limit` 件まで取得した配列に対して `slice` で疑似ページング。取得件数がそのまま `total` に入る。 |
| ソート (`orderBy`) | 任意列・複数列を `ORDER BY` で適用。 | 先頭 1 列のみ適用。複数列ソートは未対応。 |
| 検索キーワード (`searchQuery` + `searchFields`) | `ILIKE` による部分一致を全フィールドへ OR 連結。ヒット列ごとの重み付けも可能。 | 先頭フィールドのみ前方一致検索を実行。複数フィールド検索は未対応。 |
| 検索優先度 (`searchPriorityFields` / `prioritizeSearchHits`) | `CASE WHEN` を用いたランキングをサーバーで実現。 | 未使用。検索ヒット優先度の調整はできない。 |
| 条件句 (`where`) | `and` / `or` のネスト、`like` を含む主要オペレーターをサポート。 | `and` のみ対応。`or` を含むと例外。 |
| 多対多リレーション | `belongsToManyRelations` により中間テーブルを自動同期。生成直後から CRUD で利用可能。 | 非対応（domain-config でも選択不可）。複雑なリレーションが必要な場合は Drizzle へ切り替える。 |

> **補足**: 両実装とも `SearchParams` のインターフェースは共通です。Firestore 側で追加機能を実装しても呼び出し API の形は変わりません。

## 2. 実装差異と性能面の注意

### 2.1 ページング方式

- Neon: `runQuery` が SQL レベルでページングを完結させるため、取得件数は `limit` に正確に一致し、オフセットを跨いだスクロールも効率的です。
- Firestore: クエリ時に `page * limit` 件までのドキュメントを取得し、その配列に対して `slice` を行います。ページが進むほど取得件数が増えるため、メモリ消費やレスポンス遅延を考慮して `limit` を設計してください。なお `total` には取得済みの件数（最大 `page * limit` 件）が設定され、実際の総件数とは一致しません。

### 2.2 ソートと検索優先度

- Neon: `orderBy` 配列をそのままクエリに展開し、`searchPriorityFields` を指定すると検索ヒット行を `CASE WHEN` で持ち上げられます。検索順位を制御したい場合に有効です。
- Firestore: `orderBy` は最初の 1 件しか適用されず、`searchPriorityFields` も無視されます。Firestore の検索結果を UI 側で並べ替えたい場合は、追加のソート処理をクライアントで実装する必要があります。

### 2.3 検索キーワードと条件句

- Neon: 複数フィールドの部分一致や `or` 条件を SQL で素直に表現できるため、複雑な検索画面を構築する際にボトルネックになりにくい構造です。
- Firestore: `searchFields` の先頭カラムに対する前方一致のみをサポートし、`where` で `or` を利用すると例外が発生します。複雑な検索条件は現在の実装では扱えないため、UI で選択肢を制限する、あるいは Drizzle 実装を利用する設計判断が必要です。

### 2.4 多対多リレーション

- Neon: `createCrudService` が `belongsToManyRelations` を受け取り、中間テーブルの insert/delete を自動同期し、`list/get/search/query` では関連 ID の配列を合わせて返します。
- Firestore: ドキュメント構造上の制約、および index/バッチ制限が厳しいため、汎用 CRUD ではサポートしていません。domain-config でも Firestore 選択時は `belongsToMany` の入力ができないようになっています。

## 3. Firestore で機能拡張を検討する際の前提

Firestore SDK では複数列ソートや `Filter.or` を用いた複数条件検索も技術的には実装可能です。ただし、以下の理由から現行コードには未反映です。

- **複合インデックスの整備**: Firestore で複雑なクエリを実行するには、組み合わせに応じた複合インデックスを `firestore.indexes.json` で定義し、デプロイ時に適用する必要があります。現状ファイルは空であり、運用工程を含めた準備が必須です。
- **メモリとレスポンスコスト**: 取得データを一旦配列化してから処理する方針は変わらないため、ランキングや複数フィールド検索をクライアントで行うと、レスポンスサイズと処理時間の増加は避けられません。

これらの前提を踏まえ、Firestore で高度な検索機能を提供する場合は運用体制・インデックス管理コストを考慮した意思決定が求められます。

## 4. 選定指針

- **自由度を重視**: 複雑な検索条件やランキング、確定した並べ替えが必要な場合は Neon（Drizzle）版を採用してください。
- **Firestore を利用する場合**: 現状の実装では AND 条件を中心としたシンプルな検索と単一列ソートを前提に UI を設計します。多対多が必要になったら Drizzle への移行を検討するか、個別実装で Firestore 特有の制約を吸収する必要があります。

以上を参考に、ドメインの要件と運用コストに応じて DB 実装を選択・設計してください。
