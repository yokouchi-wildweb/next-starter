# ウォレット機能の設計と運用ガイド

複数種類のアプリ内リソース（通常ポイント、ボーナスポイント、コイン、ルビーなど）を共通の仕組みで管理するためのウォレット設計方針をまとめます。  
`wallet` / `wallet_history` の 2 テーブルを基盤とし、任意のリソースを `type` カラムで区別します。

---

## 1. ウォレット構造

| テーブル | 主なフィールド | 説明 |
| --- | --- | --- |
| **wallet** | `user_id` | ユーザー ID |
|  | `type` | `regular_point` / `bonus_point` / `temporary_point` / `coin` / `ruby` など、リソース名を識別する列挙。`user_id` と合わせてユニーク制約を張る |
|  | `balance` | 現在の残高 |
|  | `locked_balance` | 進行中リクエストで予約済みの残高。`balance - locked_balance` が即時に使える金額となる |
|  | `updated_at` | 最終更新 |

| テーブル | 主なフィールド | 説明 |
| --- | --- | --- |
| **wallet_history** | `id` | 履歴 ID |
|  | `user_id` | ユーザー |
|  | `type` | 更新対象のウォレット種別 |
|  | `change_method` | `INCREMENT` / `DECREMENT` / `SET` |
|  | `points_delta` | `INCREMENT/DECREMENT` では増減量、`SET` の場合は上書き後の絶対値 |
|  | `balance_before` / `balance_after` | 変動前後の残高 |
|  | `source_type` | `user_action` / `admin_action` / `system` などの区別 |
|  | `request_batch_id` | 連続処理の親 ID（単発なら `null`） |
|  | `reason` | 変化理由の短い説明 |
|  | `meta` | JSONB でリソース固有の付随情報を保持（例: `machineId`, `transactionId`） |
|  | `created_at` | 記録日時 |

---

## 2. ロックと残高の扱い

1. **残高チェック**: 利用可能残高 `available = balance - locked_balance` を算出し、操作に必要な額を満たすか判定する。
2. **予約 (lock)**: リクエスト単位で必要額 `reserve` を求め、`locked_balance += reserve` を行ってから処理を開始する。
3. **確定消費 (consume)**: バッチ処理中は各ステップで `locked_balance -= unit` と同額の `balance -= unit` をセットで行い、予約分を確定させる。
4. **失敗時の返却**: エラーで処理を中断する場合は、残っている予約分だけ `locked_balance` を戻す。`balance` は減らさないのでトランザクション整合性を保てる。

このルールにより、並列リクエストでも二重消費を防ぎ、予約／確定の状態遷移をわかりやすく管理できる。

---

## 3. リクエスト単位の管理

- 10 連 / 100 連など複数回実行する操作は、サーバーが `request_batch_id` を生成し、`wallet_history` と関連ドメイン（例: `gacha_play_history`）で同じ ID を共有する。
- UI は `request_batch_id` ごとにグループ化して表示できるため、100 連を 1 つのまとまりとして解釈できる。
- バッチジョブ（例: 有効期限切れのポイント返還）も `request_batch_id` を使えば追跡・再実行が容易になる。

---

## 4. メタ情報 (`meta`) の活用

- JSONB 形式で任意のキーを保存できる。ウォレットでは最低限として **ポイントを消費した対象の商品 ID**（`meta.productId`）や **紐づくガチャ / 注文 ID**（`meta.gachaId`, `meta.orderId` など）を格納し、履歴から直接関連エンティティをたどれるようにする。
- 管理者操作では `meta.adminId` に管理者 ID を保持し、`meta.operatorScreen` や `meta.notes` などで UI 由来の情報・問い合わせ番号を記録する（`operator_id` カラムは持たず、JSONB に一元化する）。
- その他任意のログ（例: `{ "machineId": "xxx", "machineName": "レアガチャ", "playCount": 10 }`）も必要に応じ追加できる。
- **インデックス運用**: 現状は小規模運用のためインデックスを保持せず、実際に検索・集計したいキーが固まった段階で `entities/drizzle.ts` に `CREATE INDEX` を定義し、`db:generate` → `db:push`（`drizzle-kit`）で適用する。`meta ->> 'productId'` など頻出キーには GIN インデックスを貼ることで高速化できる。

---

## 5. 多通貨対応の方針

- 新しいリソースは `type` に値を追加するだけで登録できる。例: `coin`, `ruby`, `event_token`。
- `wallet` を共通化することで CRUD・残高チェック・履歴記録の処理フローを全リソースで共有でき、テーブル増殖を避けられる。
- 期限付きリソース（`temporary_point` など）は別テーブルで期限情報を管理しつつ、還元や失効時に `wallet` / `wallet_history` を更新する。

---

## 6. 実装時のチェックリスト

1. 操作前に `available >= reserve` を確認してから `locked_balance` を更新しているか。
2. 失敗時に残りのロックを必ず解放しているか。
3. `wallet_history` に `type`, `request_batch_id`, `reason`, `meta.productId` / `meta.orderId` / `meta.adminId` など必要情報を忘れず記録しているか。
4. リクエスト単位で `request_batch_id` を共有し、表示や監査で活用できる状態か。
5. 新しいリソース種別を追加した際、`type` の enum を更新し、必要な初期残高を投入しているか。

ウォレットを共通インフラとして整備することで、ポイント以外のリソースを柔軟に追加しつつ、監査・履歴・残高管理を統一できます。

---

## 7. 既存コアドメインとの連携

- **ユーザー / 認証ドメインとの接続**: `wallet` / `wallet_history` の `user_id` は `core/user` が管理する ID を参照し、ログイン済みユーザーの残高取得や操作は `core/auth` による認証結果を前提に行う。管理者操作も `core/auth` の管理者 ID を `meta.adminId` として記録する。
