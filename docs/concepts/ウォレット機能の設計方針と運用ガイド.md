# ウォレット機能の設計と運用ガイド

複数種類のアプリ内リソース（通常ポイント、ボーナスポイント、コイン、ルビーなど）を共通の仕組みで管理するためのウォレット設計方針をまとめます。
`wallet` / `wallet_history` の 2 テーブルを基盤とし、任意のリソースを `type` カラムで区別します。

---

## 🏦 1. ウォレット構造

| テーブル | 主なフィールド | 説明 |
| --- | --- | --- |
| **wallet** | `user_id` | ユーザー ID |
|  | `type` | `regular_point` / `bonus_point` / `temporary_point` / `coin` / `ruby` など、リソース名を識別する列挙。`user_id` と合わせてユニーク制約を張る |
|  | `balance` | 現在の残高 |
|  | `locked_balance` | 進行中リクエストで予約済みの残高。`balance - locked_balance` が即時に使える金額となる |
|  | `updated_at` | 最終更新 |

| テーブル | 主なフィールド | 説明 |
| --- | --- | --- |
| **wallet_history** | `id` | 履歴 ID |
|  | `user_id` | ユーザー |
|  | `type` | 更新対象のウォレット種別 |
|  | `change_method` | `INCREMENT` / `DECREMENT` / `SET` |
|  | `points_delta` | `INCREMENT/DECREMENT` では増減量、`SET` の場合は上書き後の絶対値 |
|  | `balance_before` / `balance_after` | 変動前後の残高 |
|  | `source_type` | `user_action` / `admin_action` / `system` などの区別 |
|  | `request_batch_id` | 連続処理の親 ID（単発なら `null`） |
|  | `reason` | 変化理由の短い説明 |
|  | `meta` | JSONB でリソース固有の付随情報を保持（例: `machineId`, `transactionId`） |
|  | `created_at` | 記録日時 |

---

## 🔒 2. ロックと残高の扱い

1. **残高チェック**: 利用可能残高 `available = balance - locked_balance` を算出し、操作に必要な額を満たすか判定する。
2. **予約 (lock)**: リクエスト単位で必要額 `reserve` を求め、`locked_balance += reserve` を行ってから処理を開始する。
3. **確定消費 (consume)**: バッチ処理中は各ステップで `locked_balance -= unit` と同額の `balance -= unit` をセットで行い、予約分を確定させる。
4. **失敗時の返却**: エラーで処理を中断する場合は、残っている予約分だけ `locked_balance` を戻す。`balance` は減らさないのでトランザクション整合性を保てる。

このルールにより、並列リクエストでも二重消費を防ぎ、予約／確定の状態遷移をわかりやすく管理できる。

---

## 📦 3. リクエスト単位の管理

- 10 連 / 100 連など複数回実行する操作は、サーバーが `request_batch_id` を生成し、`wallet_history` と関連ドメイン（例: `gacha_play_history`）で同じ ID を共有する。
- UI は `request_batch_id` ごとにグループ化して表示できるため、100 連を 1 つのまとまりとして解釈できる。
- バッチジョブ（例: 有効期限切れのポイント返還）も `request_batch_id` を使えば追跡・再実行が容易になる。

---

## 📝 4. メタ情報 (`meta`) の活用

- JSONB 形式で任意のキーを保存できる。ウォレットでは最低限として **ポイントを消費した対象の商品 ID**（`meta.productId`）や **紐づくガチャ / 注文 ID**（`meta.gachaId`, `meta.orderId` など）を格納し、履歴から直接関連エンティティをたどれるようにする。
- 管理者操作では `meta.adminId` に管理者 ID を保持し、`meta.operatorScreen` や `meta.notes` などで UI 由来の情報・問い合わせ番号を記録する（`operator_id` カラムは持たず、JSONB に一元化する）。
- その他任意のログ（例: `{ "machineId": "xxx", "machineName": "レアガチャ", "playCount": 10 }`）も必要に応じ追加できる。
- **インデックス運用**: 現状は小規模運用のためインデックスを保持せず、実際に検索・集計したいキーが固まった段階で `entities/drizzle.ts` に `CREATE INDEX` を定義し、`db:generate` → `db:push`（`drizzle-kit`）で適用する。`meta ->> 'productId'` など頻出キーには GIN インデックスを貼ることで高速化できる。

---

## 💱 5. 多通貨対応の方針

- 新しいリソースは `type` に値を追加するだけで登録できる。例: `coin`, `ruby`, `event_token`。
- `wallet` を共通化することで CRUD・残高チェック・履歴記録の処理フローを全リソースで共有でき、テーブル増殖を避けられる。
- 期限付きリソース（`temporary_point` など）は別テーブルで期限情報を管理しつつ、還元や失効時に `wallet` / `wallet_history` を更新する。

---

## ✅ 6. 実装時のチェックリスト

1. 操作前に `available >= reserve` を確認してから `locked_balance` を更新しているか。
2. 失敗時に残りのロックを必ず解放しているか。
3. `wallet_history` に `type`, `request_batch_id`, `reason`, `meta.productId` / `meta.orderId` / `meta.adminId` など必要情報を忘れず記録しているか。
4. リクエスト単位で `request_batch_id` を共有し、表示や監査で活用できる状態か。
5. 新しいリソース種別を追加した際、`type` の enum を更新し、必要な初期残高を投入しているか。

ウォレットを共通インフラとして整備することで、ポイント以外のリソースを柔軟に追加しつつ、監査・履歴・残高管理を統一できます。

---

## 🔗 7. 既存コアドメインとの連携

- **ユーザー / 認証ドメインとの接続**: `wallet` / `wallet_history` の `user_id` は `core/user` が管理する ID を参照し、ログイン済みユーザーの残高取得や操作は `core/auth` による認証結果を前提に行う。管理者操作も `core/auth` の管理者 ID を `meta.adminId` として記録する。

---

## 📂 8. 連携時に参照すべきファイルとエントリ

| 利用シーン | ファイル / 関数 | ポイント |
| --- | --- | --- |
| サーバー側からポイントを操作したい | `src/features/core/wallet/services/server/walletService.ts` の `adjustBalance` / `reserveBalance` / `releaseReservation` / `consumeReservedBalance` | いずれも `tx?: TransactionClient` を取れるハイブリッド設計。外側で `db.transaction` を開始した場合は `tx` を渡し、単体実行の場合は未指定で OK。 |
| ロック→確定フローを組みたい（ガチャ・バッチ・注文確定など） | 同上 `reserveBalance` → `consumeReservedBalance`（必要に応じて `releaseReservation`） | ロック残高と実残高を分離して制御。`meta` / `requestBatchId` を渡せば履歴トレースも容易。 |
| 管理画面から調整したい | `src/app/api/admin/wallet/[userId]/adjust/route.ts`（API） + `src/features/core/wallet/components/AdminWalletAdjustModal`（UI） | 管理者の `meta.adminId` を自動付与。`useAdjustWallet` フック & `walletClient.adjustBalance` で呼び出し。 |
| クライアントから残高/履歴を参照したい | `src/features/core/wallet/hooks/useWallet`, `useWalletList`, `useWalletBalances` / `src/features/core/walletHistory/hooks/*` | SWR ベースの取得フック。`useWalletBalances` はユーザーID単位で通常ポイント/期間限定ポイントをまとめて返す。 |
| スキーマやマイグレーションを追加・更新したい | `src/features/core/wallet/entities/*`, `src/features/core/walletHistory/entities/*`, `src/registry/schemaRegistry.ts` | Drizzle 定義を更新後、`npm run db:generate` → `npm run db:push` で Neon に反映。 |
| メタ情報の型やフォームの参考資料 | `src/features/core/walletHistory/types/meta.ts`, `src/features/core/wallet/components/AdminWalletAdjustModal/formEntities.ts` | `meta` の基本キー（productId / orderId / gachaId / adminId / notes）とフォームでの入力例を参照。 |
| ドメイン自動生成を再実行したい | `src/features/core/wallet/domain.json`, `src/features/core/walletHistory/domain.json` + `npm run dc:generate -- wallet` | domain-config の修正で CRUD 雛形を再生成可能。`getDomainConfig` に登録済みなので `serviceRegistry`/`schemaRegistry` との整合も取りやすい。 |

> サービス層は「ベース CRUD (`drizzleBase.ts`)」「ドメインロジック本体 (`walletService.ts`)」「責務別ラッパー (`wrappers/*.ts`)」に分割し、用途に応じた関数をピンポイントで呼び出す。まず `walletService` を入口として捉え、必要なら `tx` を渡して既存トランザクションへ統合する。

---

## 🔄 9. トランザクション統合ガイド

1. **呼び出し側で一度だけ `db.transaction` を開始**し、その `tx` を `walletService.*(params, tx)` に渡す。
   ```ts
   await db.transaction(async (tx) => {
     await walletService.reserveBalance({ userId, walletType, amount }, tx);
     // 抽選や商品決定など中間処理
     await walletService.consumeReservedBalance({ userId, walletType, amount, sourceType: "user_action" }, tx);
   });
   ```
2. **単体で呼びたい場合**は `tx` を渡さなければ OK。内部で `db.transaction` が張られる。
3. **予約→確定**の組み合わせは `reserveBalance`/`consumeReservedBalance`、失敗時の解除は `releaseReservation` を使用。`meta` / `requestBatchId` を必ず引き継ぐとトレースしやすい。

---

## 🛠️ 10. 管理 API のリクエスト/レスポンス例

| 項目 | 内容 |
| --- | --- |
| エンドポイント | `POST /api/admin/wallet/{userId}/adjust` |
| Body 例 | ```json { "walletType": "regular_point", "changeMethod": "INCREMENT", "amount": 5000, "reason": "キャンペーン補填", "requestBatchId": "3db8...", "meta": { "orderId": "ORDER-1234", "notes": "特別対応" } } ``` |
| 成功レスポンス | `200 OK` + `{ wallet: { ...最新残高... }, history: { ...履歴レコード... } }` |
| エラー例 | `400`（Zodバリデーションエラー）, `403`（非管理者）, `409`（残高不足）, `500`（内部エラー） |

---

## 🗂️ 11. メタ情報とインデックス運用のヒント

- `meta` に追加したキーで検索したくなった場合は、`wallet_histories` に GIN インデックスを付与する。
  1. `src/features/core/walletHistory/entities/drizzle.ts` に `jsonb("meta").$type<WalletHistoryMeta>().default({})` を設定済み。
  2. 追加インデックスの例: `db.schema.sql`: `CREATE INDEX wallet_histories_meta_order_id_idx ON wallet_histories USING gin ((meta ->> 'orderId'));`
  3. `npm run db:generate` → `npm run db:push` で適用。
- `meta` のキー例: `productId`, `orderId`, `externalTransactionId`, `adminId`, `notes`。UI から渡す際もこのキー群を推奨。

---

## 🖥️ 12. 管理モーダル（AdminWalletAdjustModal）の操作フロー

1. 操作列の「ポイント操作」ボタンを押すとモーダルが開き、対象ユーザーの表示名／メール／残高（通常・期間限定）がカードで表示される。
2. 入力項目:
   - ウォレット種別（radio）
   - 操作方法（加算／減算／セット）
   - 金額（初期値なし。未入力で送信するとバリデーションエラー）
   - 理由（ユーザーに伝わるメッセージ）
   - 商品ID / 注文ID / 参照ID（任意）
   - 社内メモ（ユーザーには表示しない）
3. 送信成功でトースト「ポイントを更新しました」、失敗で `err()` 文言を表示。
4. `useAdjustWallet` が成功すると `wallets` SWR キーが再検証され、残高カードの表示も更新される。

---

## 🐛 13. デバッグ/トラブルシュート Q&A

- **Q. API 呼び出しで 500 が返る**
  A. サーバーログの `DomainError` を確認し、`walletService` で投げられたメッセージに従う。`Domain config not found: wallet` が出る場合は `schemaRegistry` と `domainConfig` の登録を確認。

- **Q. 「Route ... params is a Promise」 というエラー**
  A. Next.js 16 の API では `context.params` が Promise のため、`const { params } = await context` のように `await` が必要（このガイド内のサンプル参照）。

- **Q. 残高が更新されない／表示が古い**
  A. フロントで `useAdjustWallet` の `revalidateKeys` を適切に指定（`["wallets"]` など）しているか確認。SWR キャッシュキーとバックエンドのレスポンス整合を再チェック。

- **Q. 大量更新時のパフォーマンス**
  A. `meta` でよく検索するキーには GIN インデックスを追加。履歴テーブルの `request_batch_id` でまとまりを絞ってから更に `meta` で絞り込むと高速。

---

## 🛒 14. 通貨購入機能

アプリ内通貨（コイン、ポイント等）の購入機能については、専用ドキュメントを参照。

👉 **[コイン購入時の決済フローと外部決済連携に関する処理方針](./コイン購入時の決済フローと外部決済連携に関する処理方針.md)**

主な内容：
- `purchase_requests` テーブル設計
- リダイレクト型決済フロー
- Callback / Webhook の役割分担
- 二重購入防止と冪等性
- 決済プロバイダの抽象化
- 実装チェックリスト

---
